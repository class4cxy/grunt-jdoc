
/*
 * grunt-jdoc
 * by jdo
 * Copyright (c) 2015 alloyteam
 * Licensed under the MIT license.
 */

'use strict';

// plugin

module.exports = function (grunt) {

    var path = require('path');
    var fs = require('fs');

    var Slice = Array.prototype.slice;
    var rDocFeature = /^\s*\/\*\*([\s\S]*)\*\//g;
    var rCommField = /\s*\*\s*@([\w.-_]*)\s*(for?\s[\w.-_]*)?\s*([^\n]*)\n/g;
    // var rFieldFeature = /\s*\*\s*@([\w.-_]*)s*({[\w.-_]*})?\s*([\w.-_]*)?\s*([^\s]*)/g;
    var rSpecialField = ['param', 'example'];
    var rSpecialFieldFeature = [
        // param
        {
            exp: /\s*\*\s*@param\s*({[\w.-_]*})\s*([\w.-_]*)\s*([^\n]*)?/g,
            factory: function (holder, all, type, field, tx) {
                holder.push({
                    key: 'param',
                    field: field,
                    type: type,
                    desc: tx
                });
            }
        },
        // example
        {
            exp: /\s*\*\s*@example\s+([^@]+)/g,
            factory: function (holder, all, code) {
                holder.push({
                    key: 'example',
                    field: code.replace(/\*\s*/g, '')
                })
            }
        }
    ];
    var docJSON = {};
    var tmpMethod = {};
    // var tmpFields = {};
    var docPath = './docs';

    grunt.registerMultiTask('jdoc', 'Replace text patterns with applause.', function () {

        function matchDocFeature (filepath) {
            // reset regular lastIndex
            rDocFeature.lastIndex = 0;
            var re = rDocFeature.exec(grunt.file.read(filepath));
            var fields = [];
            var method, tx;
            if ( re && re.length > 1 && (tx=re[1]) ) {
                // grunt.log.writeln(re[1])
                // 通用字段匹配
                tx.replace(rCommField, function (all, key, belong, field) {
                    // grunt.log.writeln('dododo ----- ')
                    // grunt.log.writeln(belong)
                    key = key.replace(/\r/, '');
                    field = field.replace(/\r/, '');
                    
                    if ( key && rSpecialField.indexOf(key) === -1 ) {
                        fields.push({
                            key: key,
                            field: field,
                            belong: belong ? belong.replace('for ', '') : ''
                        });
                        // grunt.log.writeln(method)
                        if ( key === 'method' ) method = field;
                    }
                });

                // 特殊字段匹配
                rSpecialFieldFeature.forEach(function (item) {
                    // grunt.log.writeln(tx)
                    tx.replace(item.exp, function () {
                        var args = Slice.call(arguments, 0);
                        // inset holder
                        args.unshift(fields);
                        // grunt.log.writeflags(fields)
                        item.factory.apply(null, args)
                    })
                });
            }

            if ( method ) docJSON[method] = fields;
            // grunt.log.writeflags(docJSON);
        }

        /**
         * 创建名字空间
         * @param  {String} name
         * @param  {Object} space
         * @param  {Function|Object|Array|String} factory
         */
        function createNamespace(name, space, factory) {
            var arr = name.split('.');
            var len = arr.length-1;
            // var last = arr.pop();
            arr.forEach(function(a, i) {
                if ( len === i ) {
                    space[a] = factory;
                    return;
                }
                if ( !space[a] ) space[a] = {};
                space = space[a];
            });
            return space;
        }

        function handleMethod () {

            if ( docJSON ) {
                // var space = tmpMethod;
                for ( var i in docJSON) {
                    // grunt.log.writeln(i);
                    createNamespace(i, tmpMethod, docJSON[i]);
                }
                docJSON = tmpMethod;
            }
        }

        // 递归整合相同key到同一数组中
        function handleFields (root, space) {

            root = root || docJSON;
            var tmp = space ? root[space] : root;
            var singleField = ['method', 'description'];
            // array
            if ( tmp.length && tmp.forEach ) {

                var tmpFields = {};
                // 通用处理
                tmp.forEach(function (item) {
                    if ( singleField.indexOf(item.key) > -1 ) {
                        tmpFields[item.key] = item.field;
                    } else {
                        tmpFields[item.key] = tmp.filter(function (field) {
                            return field.key === item.key ? true : false;
                        });
                    }
                });

                // rewrite
                if ( space ) {
                    handleParamTree(tmpFields);
                    handleFieldsTree(tmpFields);
                    root[space] = tmpFields;
                }

            // object
            } else {
                for ( var i in tmp ) {
                    handleFields(tmp, i)
                }
            }
        }

        /**
         * 创建`param`层级化关系
         * @param  {String} field 所属字段名
         * @param  {Object} space 所属层级
         * @param  {Object} factory 附属工厂
         */
        function handleParamBelong (field, names, space, factory) {

            var curr = names.shift();
            if ( curr ) {
                // 如果参数下级为空，创建一个新的，用于给下面插入
                if ( space.length === 0 ) {
                    space[0] = {
                        field : curr
                    }
                }
                space.forEach(function (item) {
                    if ( item && item.field === curr ) {
                        if ( !item[field] ) {
                            item[field] = [];
                        }
                        if ( names.length === 1 ) {
                            // fix `field` for `param`
                            factory.field = names.shift();

                            item[field].push(factory)
                        } else {
                            handleParamBelong(field, names, item[field], factory);
                        }
                    }
                });
            }
        }

        // 参数层级化
        function handleParamTree (api) {
            var params = api.param;
            if ( params && params.length ) {
                params.forEach(function (param, k) {
                    // callback.result -> ['callback', 'result']
                    var paramNames = param.field.split('.');
                    if ( paramNames && paramNames.length > 1 ) {
                        // 先清除之前的引用
                        params[k] = null;
                        handleParamBelong('param', paramNames, params, param)
                    }
                });
            }
        }

        /**
         * 创建其他字段层级化关系
         * @param  {String} field 所属字段名
         * @param  {Object} space 所属层级
         * @param  {Object} factory 附属工厂
         */
        function handleFieldBelong (field, names, space, factory) {

            var curr = names.shift();
            if ( curr ) {
                space.forEach(function (item) {
                    if ( item && item.field === curr ) {
                        if ( names.length === 0 ) {
                            if ( !item[field] ) {
                                item[field] = [];
                            }
                            item[field].push(factory)
                        } else if ( item.param ) {
                            handleFieldBelong(field, names, item.param, factory);
                        }
                    }
                });
            }
        }

        // 其他字段层级化 `note` `support` `importent` et
        function handleFieldsTree (api) {
            // 排除名单
            var ex = ['method', 'description', 'param', 'example'];
            if ( api && typeof api === 'object' ) {
                for ( var i in api ) {
                    if ( ex.indexOf(i) === -1 ) {
                    // grunt.log.writeln(i)
                        var field = api[i];
                        // grunt.log.writeflags(field)
                        field && field.forEach && field.forEach(function (item, k){
                            if ( item.belong ) {
                                // grunt.log.writeln(item.belong.split('.'))
                                field[k] = null;
                                handleFieldBelong(i, item.belong.split('.'), api.param, item)
                            }
                        })
                    }
                }
            }
        }

        function buildJSONFile () {
            if (!grunt.file.exists(docPath)) {
                grunt.file.mkdir(docPath);
            }
            grunt.file.write(docPath+'/doc.json', JSON.stringify(docJSON));
        }


        this.files.forEach(function (file) {
            // grunt.log.writeflags(filePair);
            file.src.filter(function(filepath) {
                // Remove nonexistent files (it's up to you to filter or warn here).
                if (!grunt.file.exists(filepath)) {
                    grunt.log.warn('Source file "' + filepath + '" not found.');
                    return false;
                } else {
                    return true;
                }
            }).forEach(matchDocFeature);
        });

        handleMethod();
        handleFields();
        buildJSONFile();

    });
};
