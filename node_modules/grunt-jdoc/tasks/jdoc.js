
/*
 * grunt-jdoc
 * by jdo
 * Copyright (c) 2015 alloyteam
 * Licensed under the MIT license.
 */

'use strict';

// plugin

module.exports = function (grunt) {

    var path = require('path');
    var fs = require('fs');

    var Slice = Array.prototype.slice;
    var rDocFeature = /^\s*\/\*\*([\s\S]*)\*\//g;
    var rCommField = /\s*\*\s*@([\w.-_]*)\s*(for?\s[\w.-_]*)?\s*([^\n]*)\n/g;
    // var rFieldFeature = /\s*\*\s*@([\w.-_]*)s*({[\w.-_]*})?\s*([\w.-_]*)?\s*([^\s]*)/g;
    var rSpecialField = ['param', 'example'];
    var rSpecialFieldFeature = [
        // param
        {
            exp: /\s*\*\s*@param\s*({[\w.-_]*})\s*([\w.-_]*)\s*([^\n]*)?/g,
            factory: function (holder, all, type, field, tx) {
                holder.push({
                    field: field,
                    type: type,
                    desc: tx
                });
            }
        },
        // example
        {
            exp: /\s*\*\s*@example\s+([^@]+)/g,
            factory: function (holder, all, code) {
                holder.push(code.replace(/\*\s*/g, ''));
            }
        }
    ];
    var docJSON = {};
    var tmpMethod = {};
    // var tmpFields = {};
    var docPath = './docs';

    grunt.registerMultiTask('jdoc', 'Replace text patterns with applause.', function () {

        function matchDocFeature (filepath) {
            // reset regular lastIndex
            rDocFeature.lastIndex = 0;
            var re = rDocFeature.exec(grunt.file.read(filepath));
            var fields = [];
            var method, tx;
            if ( re && re.length > 1 && (tx=re[1]) ) {
                // grunt.log.writeln(re[1])
                // 通用字段匹配
                tx.replace(rCommField, function (all, key, belong, field) {
                    // grunt.log.writeln('dododo ----- ')
                    // grunt.log.writeln(belong)
                    key = key.replace(/\r/, '');
                    field = field.replace(/\r/, '');
                    
                    if ( key && rSpecialField.indexOf(key) === -1 ) {
                        fields.push({
                            key: key,
                            field: field,
                            belong: belong ? belong.replace('for ', '') : ''
                        });
                        // grunt.log.writeln(method)
                        if ( key === 'method' ) method = field;
                    }
                });

                // 特殊字段匹配
                rSpecialFieldFeature.forEach(function (item) {
                    tx.replace(item.exp, function () {
                        var args = Slice.call(arguments, 0);
                        // inset holder
                        args.unshift(fields);
                        // grunt.log.writeflags(fields)
                        item.factory.apply(null, args)
                    })
                });
            }

            if ( method ) docJSON[method] = fields;
        }

        /**
         * 创建名字空间
         * @param  {String} name
         */
        function createNamespace(name, space, factory) {
            var arr = name.split('.');
            var len = arr.length-1;
            // var last = arr.pop();
            arr.forEach(function(a, i) {
                if ( len === i ) {
                    space[a] = factory;
                    return;
                }
                if ( !space[a] ) space[a] = {};
                space = space[a];
            });
            return space;
        }

        function handleMethod () {

            if ( docJSON ) {
                // var space = tmpMethod;
                for ( var i in docJSON) {
                    // grunt.log.writeln(i);
                    createNamespace(i, tmpMethod, docJSON[i]);
                }
                docJSON = tmpMethod;
            }
        }

        // 递归整合相同key到同一数组中
        function handleFields (root, space) {

            root = root || docJSON;
            var tmp = space ? root[space] : root;
            var singleField = ['method', 'description'];
            // array
            if ( tmp.length && tmp.forEach ) {

                var tmpFields = {};
                // 通用处理
                tmp.forEach(function (item) {
                    if ( singleField.indexOf(item.key) > -1 ) {
                        tmpFields[item.key] = item.field;
                    } else {
                        tmpFields[item.key] = tmp.filter(function (field) {
                            return field.key === item.key ? true : false;
                        });
                    }
                });

                // rewrite
                if ( space ) {
                    root[space] = tmpFields
                }

            // object
            } else {
                for ( var i in tmp ) {
                    handleFields(tmp, i)
                }
            }
        }

        // function 

        function buildJSONFile () {
            if (!grunt.file.exists(docPath)) {
                grunt.file.mkdir(docPath);
            }
            grunt.file.write(docPath+'/doc.json', JSON.stringify(docJSON));
        }


        this.files.forEach(function (file) {
            // grunt.log.writeflags(filePair);
            file.src.filter(function(filepath) {
                // Remove nonexistent files (it's up to you to filter or warn here).
                if (!grunt.file.exists(filepath)) {
                    grunt.log.warn('Source file "' + filepath + '" not found.');
                    return false;
                } else {
                    return true;
                }
            }).forEach(matchDocFeature);
        });

        handleMethod();
        handleFields();
        buildJSONFile();

    });
};
